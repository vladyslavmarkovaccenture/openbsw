<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Eclipse OpenBSW: util::format::PrintfFormatter Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Eclipse OpenBSW
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d6/dbd/classutil_1_1format_1_1PrintfFormatter.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="../../d5/d08/classutil_1_1format_1_1PrintfFormatter-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">util::format::PrintfFormatter Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="../../d1/d61/PrintfFormatter_8h_source.html">PrintfFormatter.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a52676f2a0b2c3152174ac7397e0ce45c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dbd/classutil_1_1format_1_1PrintfFormatter.html#a52676f2a0b2c3152174ac7397e0ce45c">PrintfFormatter</a> (::<a class="el" href="../../dd/dba/classutil_1_1stream_1_1IOutputStream.html">util::stream::IOutputStream</a> &amp;strm, bool writeParam=true)</td></tr>
<tr class="separator:a52676f2a0b2c3152174ac7397e0ce45c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84595272e5a3e7a0d1be55e832e50b6e"><td class="memItemLeft" align="right" valign="top"><a id="a84595272e5a3e7a0d1be55e832e50b6e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PrintfFormatter</b> (<a class="el" href="../../d6/dbd/classutil_1_1format_1_1PrintfFormatter.html">PrintfFormatter</a> const &amp;)=delete</td></tr>
<tr class="separator:a84595272e5a3e7a0d1be55e832e50b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8384c3233174190775b6cc171ef99c"><td class="memItemLeft" align="right" valign="top"><a id="aae8384c3233174190775b6cc171ef99c"></a>
<a class="el" href="../../d6/dbd/classutil_1_1format_1_1PrintfFormatter.html">PrintfFormatter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="../../d6/dbd/classutil_1_1format_1_1PrintfFormatter.html">PrintfFormatter</a> const &amp;)=delete</td></tr>
<tr class="separator:aae8384c3233174190775b6cc171ef99c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c6fa8de7b17b3e958e31227c251fed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dbd/classutil_1_1format_1_1PrintfFormatter.html#a27c6fa8de7b17b3e958e31227c251fed">format</a> (char const *formatString,...)</td></tr>
<tr class="separator:a27c6fa8de7b17b3e958e31227c251fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe55d49c379ca6f527a540964e5a85c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dbd/classutil_1_1format_1_1PrintfFormatter.html#abe55d49c379ca6f527a540964e5a85c9">format</a> (char const *formatString, va_list ap)</td></tr>
<tr class="separator:abe55d49c379ca6f527a540964e5a85c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add9d22aa4e753c90644e2b1394b66246"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dbd/classutil_1_1format_1_1PrintfFormatter.html#add9d22aa4e753c90644e2b1394b66246">format</a> (char const *formatString, <a class="el" href="../../da/d77/classutil_1_1format_1_1IPrintfArgumentReader.html">IPrintfArgumentReader</a> &amp;argReader)</td></tr>
<tr class="separator:add9d22aa4e753c90644e2b1394b66246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ebbcba2d46ce0b3d19e48f74fda12a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dbd/classutil_1_1format_1_1PrintfFormatter.html#a4ebbcba2d46ce0b3d19e48f74fda12a5">formatText</a> (char const *text, size_t length)</td></tr>
<tr class="separator:a4ebbcba2d46ce0b3d19e48f74fda12a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a311bd25a9bee83ae5720c9fde66465"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dbd/classutil_1_1format_1_1PrintfFormatter.html#a1a311bd25a9bee83ae5720c9fde66465">formatParam</a> (<a class="el" href="../../d5/d8e/structutil_1_1format_1_1ParamInfo.html">ParamInfo</a> const &amp;paramInfo, <a class="el" href="../../d9/d72/unionutil_1_1format_1_1ParamVariant.html">ParamVariant</a> const &amp;variant)</td></tr>
<tr class="separator:a1a311bd25a9bee83ae5720c9fde66465"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Formatter that supports printf like formatting functionality on a stream object.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stream</td><td>Type of character stream to format into. A stream class has to offer two functions: <div class="fragment"><div class="line"><span class="keywordtype">void</span> appendChar(<span class="keywordtype">char</span>)</div>
</div><!-- fragment --> for appending a single character and <div class="fragment"><div class="line"><span class="keywordtype">void</span> appendChars(<span class="keywordtype">char</span> <span class="keyword">const</span>*, uint32_t)</div>
</div><!-- fragment --> for appending a given number of characters.</td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="printf_formatter_format_strings"></a>
Format strings</h1>
<p>All formatting starts with a format string. The <a class="el" href="../../d6/dbd/classutil_1_1format_1_1PrintfFormatter.html">PrintfFormatter</a> class supports only a subset of the formats the Linux GCC supports. The main difference is the lack of floating point formats.</p>
<p>The format string is a character string, beginning and ending in its initial shift state, if any. The format string is composed of zero or more directives: ordinary characters (not %), which are copied unchanged to the output stream; and conversion specifications, each of which results in fetching zero or more subsequent arguments. Each conversion specification is introduced by the character %, and ends with a conversion specifier. In between there may be (in this order) zero or more flags, an optional minimum field width, an optional precision and an optional length modifier. The arguments must correspond properly (after type promotion) with the conversion specifier. The arguments are used in the order given, where each '*' and each conversion specifier asks for the next argument (and it is an error if insufficiently many arguments are given). The implementation does not include the style using '$', which comes from the Single UNIX Specification.</p>
<h2><a class="anchor" id="printf_formatter_flag_characters"></a>
Flag characters</h2>
<p>The character % is followed by zero or more of the following flags:</p>
<dl class="section user"><dt>#</dt><dd>The value should be converted to an "alternate form". For o conversions, the first character of the output string is made zero (by prefixing a 0 if it was not zero already). For x and X conversions, a result has the string "0x" (or "0X" for X conversions) prepended to it.</dd></dl>
<dl class="section user"><dt>0</dt><dd>The value should be zero padded. For d, i, o, u, x, X the converted value is padded on the left with zeros rather than blanks. If the 0 and - flags both appear, the 0 flag is ignored. If a precision is given the 0 flag is ignored. For other conversions, the behavior is undefined.</dd></dl>
<dl class="section user"><dt>-</dt><dd>The converted value is to be left adjusted on the field boundary. (The default is right justification.) Except for n conversions, the converted value is padded on the right with blanks, rather than on the left with blanks or zeros. A - overrides a 0 if both are given.</dd></dl>
<dl class="section user"><dt>' '</dt><dd>(a space) A blank should be left before a positive number (or empty string) produced by a signed conversion.</dd></dl>
<dl class="section user"><dt>+</dt><dd>A sign (+ or -) should always be placed before a number produced by a signed conversion. By default a sign is used only for negative numbers. A + overrides a space if both are used.</dd></dl>
<h2><a class="anchor" id="printf_formatter_field_width"></a>
The field width</h2>
<p>An optional decimal digit string (with nonzero first digit) specifying a minimum field width. If the converted value has fewer characters than the field width, it will be padded with spaces on the left (or right, if the left-adjustment flag has been given). Instead of a decimal digit string one may write "*" to specify that the field width is given in the next argument which must be of type int. A negative field width is taken as a '-' flag followed by a positive field width. In no case does a nonexistent or small field width cause truncation of a field; if the result of a conversion is wider than the field width, the field is expanded to contain the conversion result.</p>
<h2><a class="anchor" id="printf_formatter_precision"></a>
The precision</h2>
<p>An optional precision, in the form of a period ('.') followed by an optional decimal digit string. Instead of a decimal digit string one may write "*" to specify that the precision is given in the next argument which must be of type int. If the precision is given as just '.', or the precision is negative, the precision is taken to be zero. This gives the minimum number of digits to appear for d, i, o, u, x, and X conversions or the maximum number of characters to be printed from a string for s conversions.</p>
<h2><a class="anchor" id="printf_formatter_length_modifier"></a>
The length modifier</h2>
<p>Here, "integer conversion" stands for d, i, o, u, x, or X conversion. The base datatype for integers is always 32 bit. 64 bit values have to be marked as long, 16 bit values as short.</p>
<dl class="section user"><dt>h</dt><dd>A following integer conversion corresponds to a signed or unsigned 16 bit integer argument, or a following n conversion corresponds to a pointer to a 16 bit integer argument.</dd></dl>
<dl class="section user"><dt>l or ll</dt><dd>(ell or ell-ell) A following integer conversion corresponds to a signed or unsigned 64 bit integer argument, or a following n conversion corresponds to a pointer to a 64 bit integer argument.</dd></dl>
<h2><a class="anchor" id="printf_formatter_conversion_specified"></a>
The conversion specifier</h2>
<p>A character that specifies the type of conversion to be applied. The conversion specifiers and their meanings are:</p>
<dl class="section user"><dt>d, i</dt><dd>The int argument is converted to signed decimal notation. The precision, if any, gives the minimum number of digits that must appear; if the converted value requires fewer digits, it is padded on the left with zeros. The default precision is 1. When 0 is printed with an explicit precision 0, the output is empty.</dd></dl>
<dl class="section user"><dt>o, u, x, X</dt><dd>The unsigned int argument is converted to unsigned octal (o), unsigned decimal (u), or unsigned hexadecimal (x and X) notation. The letters abcdef are used for x conversions; the letters ABCDEF are used for X conversions. The precision, if any, gives the minimum number of digits that must appear; if the converted value requires fewer digits, it is padded on the left with zeros. The default precision is 1. When 0 is printed with an explicit precision 0, the output is empty.</dd></dl>
<dl class="section user"><dt>c</dt><dd>the int argument is converted to an unsigned char, and the resulting character is written.</dd></dl>
<dl class="section user"><dt>s</dt><dd>The const char * argument is expected to be a pointer to an array of character type (pointer to a string). Characters from the array are written up to (but not including) a terminating null byte ('\0'); if a precision is specified, no more than the number specified are written. If a precision is given, no null byte need be present; if the precision is not specified, or is greater than the size of the array, the array must contain a terminating null byte.</dd></dl>
<dl class="section user"><dt>S</dt><dd>This is an non-standard extension: The argument is expected to be a pointer to a <a class="el" href="../../d8/d51/structutil_1_1string_1_1PlainSizedString.html">util::string::PlainSizedString</a> structure that holds a pointer to an array of character type (pointer to a string) and the length in number of characters. If a precision is specified, no more than the number specified are written.</dd></dl>
<dl class="section user"><dt>p</dt><dd>The void * pointer argument is printed in hexadecimal (as if by %#x or %#llx).</dd></dl>
<dl class="section user"><dt>n</dt><dd>The number of characters written so far is stored into the integer indicated by the int* pointer argument. No argument is converted.</dd></dl>
<dl class="section user"><dt>%</dt><dd>A '%' is written. No argument is converted. The complete conversion specification is '%%'. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a52676f2a0b2c3152174ac7397e0ce45c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52676f2a0b2c3152174ac7397e0ce45c">&#9670;&nbsp;</a></span>PrintfFormatter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">util::format::PrintfFormatter::PrintfFormatter </td>
          <td>(</td>
          <td class="paramtype">::<a class="el" href="../../dd/dba/classutil_1_1stream_1_1IOutputStream.html">util::stream::IOutputStream</a> &amp;&#160;</td>
          <td class="paramname"><em>strm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>writeParam</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor to initialize the formatter to work on a certain stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream to put characters into </td></tr>
    <tr><td class="paramname">writeParam</td><td>This controls the behaviour when the n conversion is used.<ul>
<li>true: allows to write back the number of characters written so far to the specified int * pointer argument.</li>
<li>false: All n arguments are skipped without writing back the position. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="add9d22aa4e753c90644e2b1394b66246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add9d22aa4e753c90644e2b1394b66246">&#9670;&nbsp;</a></span>format() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void util::format::PrintfFormatter::format </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>formatString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../da/d77/classutil_1_1format_1_1IPrintfArgumentReader.html">IPrintfArgumentReader</a> &amp;&#160;</td>
          <td class="paramname"><em>argReader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes the C string pointed by format to the encapsulated stream. If format includes format specifiers (subsequences beginning with %), the additional arguments following format are formatted and inserted in the resulting string replacing their respective specifiers. Use this function if you want to provide argument list in your own way.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">formatString</td><td>C string that contains the text to be written. </td></tr>
    <tr><td class="paramname">argReader</td><td>Reference to an interface that successively returns the arguments to be put out. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe55d49c379ca6f527a540964e5a85c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe55d49c379ca6f527a540964e5a85c9">&#9670;&nbsp;</a></span>format() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void util::format::PrintfFormatter::format </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>formatString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes the C string pointed by format to the encapsulated stream. If format includes format specifiers (subsequences beginning with %), the additional arguments following format are formatted and inserted in the resulting string replacing their respective specifiers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">formatString</td><td>C string that contains the text to be written. </td></tr>
    <tr><td class="paramname">ap</td><td>A value identifying a variable arguments list initialized with va_start. va_list is a special type defined in &lt;cstdarg&gt;. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27c6fa8de7b17b3e958e31227c251fed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27c6fa8de7b17b3e958e31227c251fed">&#9670;&nbsp;</a></span>format() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void util::format::PrintfFormatter::format </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>formatString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes the C string pointed by format to the encapsulated stream. If format includes format specifiers (subsequences beginning with %), the additional arguments following format are formatted and inserted in the resulting string replacing their respective specifiers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">formatString</td><td>C string that contains the text to be written. </td></tr>
    <tr><td class="paramname">...</td><td>Depending on the format string, the function may expect a sequence of additional arguments, each containing a value to be used to replace a format specifier in the format string (or a pointer to a storage location, for n). There should be at least as many of these arguments as the number of values specified in the format specifiers. Additional arguments are ignored by the function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a311bd25a9bee83ae5720c9fde66465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a311bd25a9bee83ae5720c9fde66465">&#9670;&nbsp;</a></span>formatParam()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void util::format::PrintfFormatter::formatParam </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d8e/structutil_1_1format_1_1ParamInfo.html">ParamInfo</a> const &amp;&#160;</td>
          <td class="paramname"><em>paramInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d72/unionutil_1_1format_1_1ParamVariant.html">ParamVariant</a> const &amp;&#160;</td>
          <td class="paramname"><em>variant</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts an argument value and formats it to the encapsulated stream. This function is also used from inside the format functions to output a converted argument value to the stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">paramInfo</td><td>A structure that contains the formatting to be applied to the value. </td></tr>
    <tr><td class="paramname">variant</td><td>The argument containing the value to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ebbcba2d46ce0b3d19e48f74fda12a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ebbcba2d46ce0b3d19e48f74fda12a5">&#9670;&nbsp;</a></span>formatText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void util::format::PrintfFormatter::formatText </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a C string to the encapsulated stream without scanning for any format specifier. This function is also used from inside the format functions to output constant text to the stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>C string that contains the raw text to be written to the stream. </td></tr>
    <tr><td class="paramname">length</td><td>number of characters to write to the stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="../../d1/d61/PrintfFormatter_8h_source.html">PrintfFormatter.h</a></li>
<li>PrintfFormatter.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>util</b></li><li class="navelem"><b>format</b></li><li class="navelem"><a class="el" href="../../d6/dbd/classutil_1_1format_1_1PrintfFormatter.html">PrintfFormatter</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
